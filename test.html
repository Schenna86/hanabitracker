<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hanabi Tracker</title>
  <style>
    body {
      font-family: sans-serif;
      background: #424242;
      margin: 0;
      padding: 1rem;
    }
    .container {
      max-width: 1000px;
      margin: auto;
    }
    .header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
    }
    .card {
      background: #7d7d7d;
      border: 2px solid #ccc;
      border-radius: 1rem;
      padding: 0.75rem;
      text-align: center;
      cursor: pointer;
      transition: 0.2s;
      position: relative;
    }
    .card.selected {
      border-color: #007bff;
      box-shadow: 0 0 10px rgba(0,123,255,0.5);
    }
    .card .main {
      font-size: 2rem;
      font-weight: bold;
    }
    .indizi-negativi {
      font-size: 0.75rem;
      margin-top: 0.3rem;
      color: #ccc;
    }
    .controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    .control-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    .controls button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      min-width: 60px;
    }
    .yellow { color: gold; }
    .red { color: red; }
    .blue { color: blue; }
    .green { color: green; }
    .white { color: white; }
    .rainbow {
      background: linear-gradient(to right, red, orange, yellow, green, blue, violet);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: bold;
    }
    .reset-button {
      position: absolute;
      top: 4px;
      right: 4px;
      background: #f0f0f0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.7rem;
      padding: 2px 5px;
    }
    .residue-section {
      align-items: center;
      margin-top: 2rem;
    }
    .residue-row {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      gap: 0.3rem;
      flex-wrap: wrap;
    }
    .residue-label {
      visibility: hidden;
      width: 0;
      margin: 0;
      padding: 0;
    }
    .residue-button {
      padding: 0.3rem 0.6rem;
      border-radius: 5px;
      background: #ccc;
      border: 1px solid #ccc;
      cursor: pointer;
      min-width: 28px;
      text-align: center;
      transition: background 0.2s, opacity 0.2s;
    }
    .residue-button.oscurata {
      background: #333;
      color: white;
      opacity: 0.4;
    }
    .residue-row[data-colore="Gia"] .residue-button { color: gold; }
    .residue-row[data-colore="Ros"] .residue-button { color: red; }
    .residue-row[data-colore="Blu"] .residue-button { color: blue; }
    .residue-row[data-colore="Ver"] .residue-button { color: green; }
    .residue-row[data-colore="Bia"] .residue-button { color: white; }
    .residue-row[data-colore="Arcobaleno"] .residue-button {
      background: linear-gradient(to right, red, orange, yellow, green, blue, violet);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-weight: bold;
    }

    .versione {
      position: fixed;
      bottom: 10px;
      right: 15px;
      font-size: 0.85rem;
      color: #aaa;
      opacity: 0.7;
    }
    .hantrack {
      position: fixed;
      bottom: 10px;
      left: 15px;
      font-size: 0.85rem;
      color: #aaa;
      opacity: 0.7;
    }
   .card-hints {
  margin-top: 6px;
  text-align: center;
  font-size: 0.88rem;
  width: 100%;
}
.card-columns-wrap {
  display: flex;
  justify-content: center;
  gap: 20px;
  width: 100%;
  margin-top: 2px;
}
.card-col-table {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 2px;
  min-width: 58px;
  max-width: 72px;
}
.card-row-flex {
  display: flex;
  align-items: center;
  gap: 6px;
  min-height: 21px;
}
.color-dot, .number-hint {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1em;
  margin-right: 3px;
  opacity: 1;
}
.color-dot.oscurato, .number-hint.oscurato {
  opacity: 0.09;
  filter: grayscale(100%);
}
.number-hint {
  background: #1c1c1c66;
  border-radius: 7px;
  color: #fff;
  width: 18px;
  height: 18px;
  text-align: center;
  font-size: 1em;
  font-weight: bold;
  line-height: 18px;
}
.color-dot.yellow { background: gold; }
.color-dot.red { background: red; }
.color-dot.blue { background: blue; }
.color-dot.green { background: green; }
.color-dot.white { background: white; border: 1px solid #ccc; }
.color-dot.rainbow {
  background: linear-gradient(to right, red, orange, yellow, green, blue, violet);
}
.probability-value {
  font-size: 0.89em;
  color: #eee;
  min-width: 29px;
  text-align: left;
  margin: 0 2px 0 0;
}
.probability-value.spenta {
  opacity: 0.15;
}
@media (max-width: 600px) {
  .card-hints { font-size: 1.01em;}
  .card-columns-wrap { gap: 8px;}
  .card-col-table { min-width: 50px; max-width: 60px;}
  .probability-value { font-size: 0.97em; }
}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <button onclick="tornaAllaHome()">Torna alla Home</button>
      <button onclick="undo()">Undo</button>
      <button onclick="generaNegazioni()">Genera Negazioni</button>
    </div>

    <div class="cards" id="cards"></div>
    <div class="controls">
      <div class="control-row" id="color-controls"></div>
      <div class="control-row" id="number-controls"></div>
    </div>
    <div class="residue-section">
      <h2>Carte Residue</h2>
      <div id="residue-tracker"></div>
    </div>
  </div>
  <div style="text-align: center; margin-top: 1rem;">
    <label style="color: white;">
      <input type="checkbox" id="wakelock-toggle" />
      Mantieni schermo attivo
    </label>
  </div>
  <script>
const urlParams = new URLSearchParams(window.location.search);
const numCarte = parseInt(urlParams.get("carte")) || 4;
const arcobalenoAttivo = ["on", "true", "1"].includes(urlParams.get("arcobaleno"));
const resetMode = urlParams.get("reset") || "sinistra";

const COLORI_INDIZI = ['Gia', 'Ros', 'Blu', 'Ver', 'Bia'];
const COLORI = arcobalenoAttivo ? [...COLORI_INDIZI, 'Arcobaleno'] : [...COLORI_INDIZI];
const NUMERI = ['1','2','3','4','5'];
const DISTRIBUZIONE = ['1','1','1','2','2','3','3','4','4','5'];

let carte = [];
let carteResidue = {};
let numeriOscurati = [];
let historyStack = [];

function coloreClasse(c) {
  return {
    Gia: 'yellow', Ros: 'red', Blu: 'blue',
    Ver: 'green', Bia: 'white', Arcobaleno: 'rainbow'
  }[c] || '';
}

function inizializzaCarteResidue() {
  COLORI.forEach(col => {
    carteResidue[col] = DISTRIBUZIONE.map((n, idx) => ({
      numero: n, id: `${col}-${idx}`, oscurata: false
    }));
  });
}

function pushHistory() {
  historyStack.push(JSON.parse(JSON.stringify({ carte, carteResidue, numeriOscurati })));
  if (historyStack.length > 100) historyStack.shift();
}

function undo() {
  if (!historyStack.length) return;
  const prev = historyStack.pop();
  carte = prev.carte;
  carteResidue = prev.carteResidue;
  numeriOscurati = prev.numeriOscurati;
  render();
  saveState();
}

function saveState() {
  const state = { carte, carteResidue, numeriOscurati };
  localStorage.setItem('hanabiTrackerState', JSON.stringify(state));
}

function loadState() {
  const saved = localStorage.getItem('hanabiTrackerState');
  if (saved) {
    try {
      const state = JSON.parse(saved);
      carte = state.carte;
      carteResidue = state.carteResidue;
      numeriOscurati = state.numeriOscurati;
      return true;
    } catch {}
  }
  return false;
}

function start(n) {
  historyStack = [];
  carte = Array(n).fill(0).map(() => ({
    colore: [], notColor: [], numero: null, notNumber: [],
    notColorAuto: [], notNumberAuto: [], selected: false
  }));
  inizializzaCarteResidue();
  numeriOscurati = [];
  render();
  saveState();
}

function toggleSelection(i) {
  pushHistory();
  carte[i].selected = !carte[i].selected;
  render();
  saveState();
}

function assegnaIndizioColore(colore) {
  if (!carte.some(c => c.selected)) return;
  pushHistory();

  const selezionate = carte.filter(c => c.selected);
  const altre = carte.filter(c => !c.selected);

  selezionate.forEach(c => {
    if (!c.colore.includes(colore)) c.colore.push(colore);
  });

  altre.forEach(c => {
    if (!c.notColor.includes(colore)) c.notColor.push(colore);
    if (!c.notColor.includes('Arcobaleno')) c.notColor.push('Arcobaleno');
  });

  carte.forEach(c => c.selected = false);
  aggiornaArcobaleni();
  render();
  saveState();
}

function assegnaIndizioNumero(numero) {
  if (!carte.some(c => c.selected)) return;
  pushHistory();
  carte.forEach(c => {
    if (c.selected) {
      c.numero = numero;
    } else {
      if (!c.notNumber.includes(numero)) c.notNumber.push(numero);
    }
    c.selected = false;
  });
  render();
  saveState();
}

function aggiornaArcobaleni() {
  if (!arcobalenoAttivo) return;
  carte.forEach(c => {
    if (c.colore.length > 1) c.colore = ['Arcobaleno'];
  });
}

function resetCard(i) {
  pushHistory();
  const nuovaCarta = {
    colore: [], notColor: [], numero: null, notNumber: [],
    notColorAuto: [], notNumberAuto: [], selected: false
  };
  if (resetMode === "sinistra") {
    carte.splice(i, 1);
    carte.unshift(nuovaCarta);
  } else if (resetMode === "destra") {
    carte.splice(i, 1);
    carte.push(nuovaCarta);
  } else {
    carte[i] = nuovaCarta;
  }
  render();
  saveState();
}

function toggleResidua(colore, id) {
  const carta = carteResidue[colore].find(c => c.id === id);
  if (carta) {
    carta.oscurata = !carta.oscurata;
    render();
    saveState();
  }
}

function tornaAllaHome() {
  if (confirm("Vuoi davvero tornare alla Home? ATTENZIONE: perderai tutti i dati salvati.")) {
    localStorage.removeItem('hanabiTrackerState');
    window.location.href = "index.html";
  }
}

function generaNegazioni() {
  pushHistory();
  carte.forEach(c => {
    c.notColorAuto = [];
    c.notNumberAuto = [];

    if (c.colore.length === 1 && c.numero === null) {
      const presenti = new Set(carteResidue[c.colore[0]].filter(r => !r.oscurata).map(r => r.numero));
      NUMERI.forEach(n => {
        if (!presenti.has(n)) c.notNumberAuto.push(n);
      });
    }

    if (c.numero !== null && c.colore.length === 0) {
      COLORI.forEach(col => {
        const match = carteResidue[col].some(r => !r.oscurata && r.numero === c.numero);
        if (!match) c.notColorAuto.push(col);
      });
    }
  });
  render();
  saveState();
}

// --- Calcolo probabilità corrette (solo su combinazioni realmente possibili)
function calcolaProbabilitaColori(carta) {
  // Se ha un numero certo, conta solo le carte residue di quel numero!
  const numeri = carta.numero ? [carta.numero] : NUMERI;
  const colori = carta.colore.length === 1
    ? (arcobalenoAttivo && carta.colore[0] !== 'Arcobaleno' ? [carta.colore[0], 'Arcobaleno'] : [carta.colore[0]])
    : COLORI;

  // Per ogni colore mostro, conta solo le residue di quel colore E tra i numeri possibili (o certo)
  let counts = colori.map(col => {
    if (carta.notColor.includes(col)) return 0;
    return carteResidue[col].filter(x =>
      !x.oscurata &&
      numeri.includes(x.numero) &&
      !carta.notNumber.includes(x.numero)
    ).length;
  });
  let totali = counts.reduce((a, b) => a + b, 0);

  return colori.map((col, i) => {
    if (carta.notColor.includes(col)) return "--";
    if (totali === 0) return "0%";
    let percent = Math.round((counts[i] / totali) * 100);
    return percent + "%";
  });
}

function calcolaProbabilitaNumeri(carta) {
  // Se ha un colore certo, conta solo le residue di quei colori!
  const colori = carta.colore.length === 1
    ? (arcobalenoAttivo && carta.colore[0] !== 'Arcobaleno' ? [carta.colore[0], 'Arcobaleno'] : [carta.colore[0]])
    : COLORI;
  const numeri = carta.numero ? [carta.numero] : NUMERI;

  // Per ogni numero mostro, conta solo le residue di quei colori E numero = quello
  let counts = numeri.map(num => {
    if (carta.notNumber.includes(num)) return 0;
    let sum = 0;
    for (let col of colori) {
      sum += carteResidue[col].filter(x =>
        !x.oscurata &&
        x.numero === num &&
        !carta.notColor.includes(col)
      ).length;
    }
    return sum;
  });
  let totali = counts.reduce((a, b) => a + b, 0);

  return numeri.map((num, i) => {
    if (carta.notNumber.includes(num)) return "--";
    if (totali === 0) return "0%";
    let percent = Math.round((counts[i] / totali) * 100);
    return percent + "%";
  });
}

// --- Render
function render() {
  const cardsEl = document.getElementById('cards');
  cardsEl.innerHTML = carte.map((c, i) => {
    let content = '?';
    let cls = '';
    if (c.numero && c.colore.length) {
      cls = coloreClasse(c.colore[0]);
      content = `<span class="${cls}">${c.numero}</span>`;
    } else if (c.numero) {
      content = c.numero;
    } else if (c.colore.length) {
      cls = coloreClasse(c.colore[0]);
      content = `<span class="${cls}">?</span>`;
    }

    const coloriDaMostrare = c.colore.length === 1
      ? (arcobalenoAttivo && c.colore[0] !== 'Arcobaleno' ? [c.colore[0], 'Arcobaleno'] : [c.colore[0]])
      : COLORI;
    const numeriDaMostrare = c.numero ? [c.numero] : NUMERI;

    const negColor = c.notColor;
    const negNumber = c.notNumber;
    const negColorAuto = c.notColorAuto || [];
    const negNumberAuto = c.notNumberAuto || [];

    // PROBABILITA'
    const probCol = calcolaProbabilitaColori(c);
    const probNum = calcolaProbabilitaNumeri(c);

    // DUE COLONNE: colori a sinistra, numeri a destra
    return `
      <div>
        <div class="card${c.selected ? ' selected' : ''}" onclick="toggleSelection(${i})">
          <button class="reset-button" onclick="event.stopPropagation(); resetCard(${i})">✕</button>
          <div class="main">${content}</div>
        </div>
        <div class="card-hints">
          <div class="card-columns-wrap">
            <div class="card-col-table">
              ${coloriDaMostrare.map((col, idx) => `
                <div class="card-row-flex">
                  <div class="color-dot ${coloreClasse(col)}${negColor.includes(col) ? ' oscurato' : ''}"></div>
                  <span class="probability-value${negColor.includes(col) ? ' spenta' : ''}">${probCol[idx]}</span>
                </div>
              `).join('')}
            </div>
            <div class="card-col-table">
              ${numeriDaMostrare.map((num, idx) => `
                <div class="card-row-flex">
                  <div class="number-hint${negNumber.includes(num) ? ' oscurato' : ''}">${num}</div>
                  <span class="probability-value${negNumber.includes(num) ? ' spenta' : ''}">${probNum[idx]}</span>
                </div>
              `).join('')}
            </div>
          </div>
          ${(negColorAuto.length || negNumberAuto.length) ? `
            <div class="indizi-negativi">
              ${negColorAuto.length ? `Auto Non: ${negColorAuto.join(', ')}` : ''}
              ${negNumberAuto.length ? `<br>Auto ≠: ${negNumberAuto.join(', ')}` : ''}
            </div>` : ''}
        </div>
      </div>
    `;
  }).join('');

  document.getElementById('color-controls').innerHTML = COLORI_INDIZI.map(c =>
    `<button class="${coloreClasse(c)}" onclick="assegnaIndizioColore('${c}')">${c}</button>`).join('');

  document.getElementById('number-controls').innerHTML = NUMERI.map(n =>
    `<button onclick="assegnaIndizioNumero('${n}')">${n}</button>`).join('');

  document.getElementById('residue-tracker').innerHTML = COLORI.map(col => `
    <div class="residue-row" data-colore="${col}">
      <div class="residue-label"></div>
      ${carteResidue[col].map(c =>
        `<div class="residue-button${c.oscurata ? ' oscurata' : ''}" onclick="toggleResidua('${col}', '${c.id}')">${c.numero}</div>`).join('')}
    </div>
  `).join('');
}
if (!loadState()) start(numCarte);
else render();

let wakeLock = null;

async function attivaWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => console.log('🔓 Wake Lock rilasciato'));
    }
  } catch (err) {
    console.error(`${err.name}, ${err.message}`);
  }
}

document.addEventListener('visibilitychange', () => {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    attivaWakeLock();
  }
});

const wakeLockToggle = document.getElementById('wakelock-toggle');
const savedPref = localStorage.getItem('hanabiWakeLock');
if (savedPref === 'true') {
  wakeLockToggle.checked = true;
  attivaWakeLock();
}
wakeLockToggle.addEventListener('change', async function () {
  localStorage.setItem('hanabiWakeLock', this.checked ? 'true' : 'false');
  if (this.checked) await attivaWakeLock();
  else if (wakeLock) {
    await wakeLock.release();
    wakeLock = null;
  }
});
</script>
<div class="hantrack">Hanabi tracker</div>
<div class="versione">1.3</div>
</body>
</html>
